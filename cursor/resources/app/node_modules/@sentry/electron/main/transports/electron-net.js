const core = require('@sentry/core');
const utils = require('@sentry/utils');
const electron = require('electron');
const stream = require('stream');
const urlModule = require('url');
const zlib = require('zlib');

// Estimated maximum size for reasonable standalone event
const GZIP_THRESHOLD = 1024 * 32;
/**
 * Gets a stream from a Buffer or string
 * We don't have Readable.from in earlier versions of node
 */
function streamFromBody(body) {
    return new stream.Readable({
        read() {
            this.push(body);
            this.push(null);
        },
    });
}
function getRequestOptions(url) {
    const { hostname, pathname, port, protocol, search } = new urlModule.URL(url);
    return {
        method: 'POST',
        hostname,
        path: `${pathname}${search}`,
        port: parseInt(port, 10),
        protocol,
    };
}
/**
 * Creates a Transport that uses Electrons net module to send events to Sentry.
 */
function makeElectronTransport(options) {
    return core.createTransport(options, createElectronNetRequestExecutor(options.url, options.headers || {}));
}
/**
 * Creates a RequestExecutor to be used with `createTransport`.
 */
function createElectronNetRequestExecutor(url, baseHeaders) {
    baseHeaders['Content-Type'] = 'application/x-sentry-envelope';
    return function makeRequest(request) {
        return electron.app.whenReady().then(() => new Promise((resolve, reject) => {
            let bodyStream = streamFromBody(request.body);
            const headers = { ...baseHeaders };
            if (request.body.length > GZIP_THRESHOLD) {
                headers['content-encoding'] = 'gzip';
                bodyStream = bodyStream.pipe(zlib.createGzip());
            }
            const req = electron.net.request(getRequestOptions(url));
            for (const [header, value] of Object.entries(headers)) {
                req.setHeader(header, value);
            }
            req.on('response', (res) => {
                res.on('error', reject);
                res.on('data', () => {
                    // Drain socket
                });
                res.on('end', () => {
                    // Drain socket
                });
                // "Key-value pairs of header names and values. Header names are lower-cased."
                // https://nodejs.org/api/http.html#http_message_headers
                const retryAfterHeader = res.headers['retry-after'] ?? null;
                const rateLimitsHeader = res.headers['x-sentry-rate-limits'] ?? null;
                resolve({
                    statusCode: res.statusCode,
                    headers: utils.dropUndefinedKeys({
                        'retry-after': Array.isArray(retryAfterHeader) ? retryAfterHeader[0] || null : retryAfterHeader,
                        'x-sentry-rate-limits': Array.isArray(rateLimitsHeader)
                            ? rateLimitsHeader[0] || null
                            : rateLimitsHeader,
                    }),
                });
            });
            req.on('error', reject);
            // The docs say that ClientRequest is Writable but the types don't match exactly
            bodyStream.pipe(req);
        }));
    };
}

exports.createElectronNetRequestExecutor = createElectronNetRequestExecutor;
exports.makeElectronTransport = makeElectronTransport;//# sourceMappingURL=http://go/sourcemap/sourcemaps/5b19bac7a947f54e4caa3eb7e4c5fbf832389850/node_modules/@sentry/electron/main/transports/electron-net.js.map
