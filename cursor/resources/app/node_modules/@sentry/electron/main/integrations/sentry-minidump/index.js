const core = require('@sentry/core');
const utils = require('@sentry/utils');
const electron = require('electron');
const scope = require('../../../common/scope.js');
const context = require('../../context.js');
const electronNormalize = require('../../electron-normalize.js');
const renderers = require('../../renderers.js');
const sessions = require('../../sessions.js');
const store = require('../../store.js');
const minidumpLoader = require('./minidump-loader.js');

/**
 * Sends minidumps via the Sentry uploader
 */
const sentryMinidumpIntegration = core.defineIntegration((options = {}) => {
    // The remaining number of minidumps that can be sent in this session
    let minidumpsRemaining = options.maxMinidumpsPerSession || 10;
    // Store to persist context information beyond application crashes.
    let scopeStore;
    // We need to store the scope in a variable here so it can be attached to minidumps
    let scopeLastRun;
    let minidumpLoader$1;
    function startCrashReporter() {
        utils.logger.log('Starting Electron crashReporter');
        electron.crashReporter.start({
            companyName: '',
            ignoreSystemCrashHandler: true,
            productName: electron.app.name || electron.app.getName(),
            // Empty string doesn't work for Linux Crashpad and no submitURL doesn't work for older versions of Electron
            submitURL: 'https://f.a.k/e',
            uploadToServer: false,
            compress: true,
        });
    }
    function setupScopeListener(client) {
        function scopeChanged(scope) {
            // Since the initial scope read is async, we need to ensure that any writes do not beat that
            // https://github.com/getsentry/sentry-electron/issues/585
            setImmediate(async () => scopeStore?.set({
                scope,
                event: await context.getEventDefaults(client),
            }));
        }
        scope.addScopeListener((scope) => {
            scopeChanged(scope);
        });
        scopeChanged(scope.getScopeData());
    }
    async function sendNativeCrashes(client, eventIn) {
        // Whenever we are called, assume that the crashes we are going to load down
        // below have occurred recently. This means, we can use the same event data
        // for all minidumps that we load now. There are two conditions:
        //
        //  1. The application crashed and we are just starting up. The stored
        //     breadcrumbs and context reflect the state during the application
        //     crash.
        //
        //  2. A renderer process crashed recently and we have just been notified
        //     about it. Just use the breadcrumbs and context information we have
        //     right now and hope that the delay was not too long.
        const event = eventIn;
        // If this is a native main process crash, we need to apply the scope and context from the previous run
        if (event.tags?.['event.process'] === 'browser') {
            const previousRun = await scopeLastRun;
            if (previousRun) {
                if (previousRun.scope) {
                    core.applyScopeDataToEvent(event, previousRun.scope);
                }
                event.release = previousRun.event?.release || event.release;
                event.environment = previousRun.event?.environment || event.environment;
                event.contexts = previousRun.event?.contexts || event.contexts;
            }
        }
        if (!event) {
            return false;
        }
        if (minidumpsRemaining <= 0) {
            utils.logger.log('Not sending minidumps because the limit has been reached');
        }
        // If the SDK is not enabled, or we've already reached the minidump limit, tell the loader to delete all minidumps
        const deleteAll = client.getOptions().enabled === false || minidumpsRemaining <= 0;
        let minidumpFound = false;
        await minidumpLoader$1?.(deleteAll, (attachment) => {
            minidumpFound = true;
            if (minidumpsRemaining > 0) {
                minidumpsRemaining -= 1;
                core.captureEvent(event, { attachments: [attachment] });
            }
        });
        return minidumpFound;
    }
    async function sendRendererCrash(client, options, contents, details) {
        const { getRendererName } = options;
        const crashedProcess = getRendererName?.(contents) || 'renderer';
        utils.logger.log(`'${crashedProcess}' process '${details.reason}'`);
        const found = await sendNativeCrashes(client, {
            contexts: {
                electron: {
                    crashed_url: renderers.getRendererProperties(contents.id)?.url || 'unknown',
                    details,
                },
            },
            level: 'fatal',
            // The default is javascript
            platform: 'native',
            tags: {
                'event.environment': 'native',
                'event.process': crashedProcess,
                'exit.reason': details.reason,
            },
        });
        if (found) {
            sessions.sessionCrashed();
        }
    }
    async function sendChildProcessCrash(client, options, details) {
        utils.logger.log(`${details.type} process has ${details.reason}`);
        const found = await sendNativeCrashes(client, {
            contexts: {
                electron: { details },
            },
            level: 'fatal',
            // The default is javascript
            platform: 'native',
            tags: {
                'event.environment': 'native',
                'event.process': details.type,
                'exit.reason': details.reason,
                event_type: 'native',
            },
        });
        if (found) {
            sessions.sessionCrashed();
        }
    }
    return {
        name: 'SentryMinidump',
        setup(client) {
            // Mac AppStore builds cannot run the crash reporter due to the sandboxing
            // requirements. In this case, we prevent enabling native crashes entirely.
            // https://electronjs.org/docs/tutorial/mac-app-store-submission-guide#limitations-of-mas-build
            if (process.mas) {
                return;
            }
            startCrashReporter();
            scopeStore = new store.BufferedWriteStore(electronNormalize.getSentryCachePath(), 'scope_v3', {
                scope: new core.Scope().getScopeData(),
            });
            scopeLastRun = scopeStore.get();
            minidumpLoader$1 = minidumpLoader.getMinidumpLoader();
            const options = client.getOptions();
            setupScopeListener(client);
            if (!options?.dsn) {
                throw new utils.SentryError('Attempted to enable Electron native crash reporter but no DSN was supplied');
            }
            renderers.trackRendererProperties();
            electron.app.on('render-process-gone', async (_, contents, details) => {
                if (electronNormalize.EXIT_REASONS.includes(details.reason)) {
                    await sendRendererCrash(client, options, contents, details);
                }
            });
            electron.app.on('child-process-gone', async (_, details) => {
                if (electronNormalize.EXIT_REASONS.includes(details.reason)) {
                    await sendChildProcessCrash(client, options, details);
                }
            });
            // Start to submit recent minidump crashes. This will load breadcrumbs and
            // context information that was cached on disk in the previous app run, prior to the crash.
            sendNativeCrashes(client, {
                level: 'fatal',
                platform: 'native',
                tags: {
                    'event.environment': 'native',
                    'event.process': 'browser',
                },
            })
                .then((minidumpsFound) => 
            // Check for previous uncompleted session. If a previous session exists
            // and no minidumps were found, its likely an abnormal exit
            sessions.checkPreviousSession(minidumpsFound))
                .catch((error) => utils.logger.error(error));
        },
    };
});

exports.sentryMinidumpIntegration = sentryMinidumpIntegration;//# sourceMappingURL=http://go/sourcemap/sourcemaps/5b19bac7a947f54e4caa3eb7e4c5fbf832389850/node_modules/@sentry/electron/main/integrations/sentry-minidump/index.js.map
