const core = require('@sentry/core');
const utils = require('@sentry/utils');
const electron = require('electron');
const scope = require('../../common/scope.js');
const context = require('../context.js');
const electronNormalize = require('../electron-normalize.js');
const merge = require('../merge.js');
const normalize = require('../normalize.js');
const sessions = require('../sessions.js');

/** Is object defined and has keys */
function hasKeys(obj) {
    return obj !== undefined && Object.keys(obj).length > 0;
}
/** Gets a Scope object with user, tags and extra */
function getScope(options) {
    const scope$1 = scope.getScopeData();
    if (!scope$1) {
        return {};
    }
    return {
        release: options.release,
        environment: options.environment,
        /* eslint-disable @typescript-eslint/no-unsafe-member-access */
        ...(hasKeys(scope$1.user) && { user: scope$1.user }),
        ...(hasKeys(scope$1.tags) && { tags: scope$1.tags }),
        ...(hasKeys(scope$1.extra) && { extra: scope$1.extra }),
        /* eslint-enable @typescript-eslint/no-unsafe-member-access */
    };
}
/** Chunks up event JSON into 1 or more parameters for use with the native Electron uploader
 *
 * Returns chunks with keys and values:
 * {
 *    sentry__1: '{ json...',
 *    sentry__2: 'more json...',
 *    sentry__x: 'end json }',
 * }
 */
function getNativeUploaderExtraParams(event) {
    const maxBytes = 20300;
    /** Max chunk sizes are in bytes so we can't chunk by characters or UTF8 could bite us.
     *
     * We attempt to split by space (32) and double quote characters (34) as there are plenty in JSON
     * and they are guaranteed to not be the first byte of a multi-byte UTF8 character.
     */
    let buf = Buffer.from(JSON.stringify(event));
    const chunks = [];
    while (buf.length) {
        // Find last '"'
        let i = buf.lastIndexOf(34, maxBytes + 1);
        // Or find last ' '
        if (i < 0)
            i = buf.lastIndexOf(32, maxBytes + 1);
        // Or find first '"'
        if (i < 0)
            i = buf.indexOf(34, maxBytes);
        // Or find first ' '
        if (i < 0)
            i = buf.indexOf(32, maxBytes);
        // We couldn't find any space or quote chars so split at maxBytes and hope for the best 🤷‍♂️
        if (i < 0)
            i = maxBytes;
        chunks.push(buf.subarray(0, i + 1).toString());
        buf = buf.subarray(i + 1);
    }
    return chunks.reduce((acc, cur, i) => {
        acc[`sentry__${i + 1}`] = cur;
        return acc;
    }, {});
}
/**
 * Returns the minidump endpoint in Sentry
 * @param dsn Dsn
 */
function minidumpUrlFromDsn(dsn) {
    const dsnComponents = utils.makeDsn(dsn);
    if (!dsnComponents) {
        return undefined;
    }
    const { host, path, projectId, port, protocol, publicKey } = dsnComponents;
    return `${protocol}://${host}${port !== '' ? `:${port}` : ''}${path !== '' ? `/${path}` : ''}/api/${projectId}/minidump/?sentry_key=${publicKey}`;
}
/**
 * Sends minidumps via the Electron built-in uploader.
 */
const electronMinidumpIntegration = core.defineIntegration(() => {
    /** Counter used to ensure no race condition when updating extra params */
    let updateEpoch = 0;
    async function getNativeUploaderEvent(client, scope) {
        const event = merge.mergeEvents(await context.getEventDefaults(client), {
            sdk: context.getSdkInfo(),
            event_id: utils.uuid4(),
            level: 'fatal',
            platform: 'native',
            tags: { 'event.environment': 'native' },
        });
        core.applyScopeDataToEvent(event, scope);
        delete event.sdkProcessingMetadata;
        // Normalise paths
        return normalize.normalizePaths(event, electron.app.getAppPath());
    }
    function updateExtraParams(client, scope) {
        updateEpoch += 1;
        const currentEpoch = updateEpoch;
        getNativeUploaderEvent(client, scope)
            .then((event) => {
            if (currentEpoch !== updateEpoch) {
                return;
            }
            // Update the extra parameters in the main process
            const mainParams = getNativeUploaderExtraParams(event);
            for (const [key, value] of Object.entries(mainParams)) {
                electron.crashReporter.addExtraParameter(key, value);
            }
        })
            .catch((error) => utils.logger.error(error));
    }
    function startCrashReporter(options) {
        const submitURL = minidumpUrlFromDsn(options.dsn || '');
        if (!submitURL) {
            utils.logger.log('Invalid DSN. Cannot start Electron crashReporter');
            return;
        }
        // We don't add globalExtra when Breakpad is in use because it doesn't support JSON like strings:
        // https://github.com/electron/electron/issues/29711
        const globalExtra = electronNormalize.usesCrashpad() ? { sentry___initialScope: JSON.stringify(getScope(options)) } : undefined;
        utils.logger.log('Starting Electron crashReporter');
        electron.crashReporter.start({
            companyName: '',
            ignoreSystemCrashHandler: true,
            productName: electron.app.name || electron.app.getName(),
            submitURL,
            uploadToServer: true,
            compress: true,
            globalExtra,
        });
    }
    function setupScopeListener(client) {
        scope.addScopeListener((scope) => {
            updateExtraParams(client, scope);
        });
    }
    return {
        name: 'ElectronMinidump',
        setup(client) {
            // Mac AppStore builds cannot run the crash reporter due to the sandboxing
            // requirements. In this case, we prevent enabling native crashes entirely.
            // https://electronjs.org/docs/tutorial/mac-app-store-submission-guide#limitations-of-mas-build
            if (process.mas) {
                return;
            }
            const clientOptions = client.getOptions();
            if (!clientOptions?.dsn) {
                throw new utils.SentryError('Attempted to enable Electron native crash reporter but no DSN was supplied');
            }
            startCrashReporter(clientOptions);
            // If a renderer process crashes, mark any existing session as crashed
            electron.app.on('render-process-gone', (_, __, details) => {
                if (electronNormalize.CRASH_REASONS.includes(details.reason)) {
                    sessions.sessionCrashed();
                }
            });
            // If we're using the Crashpad minidump uploader, we set extra parameters whenever the scope updates
            if (electronNormalize.usesCrashpad()) {
                setupScopeListener(client);
            }
            // Check if last crash report was likely to have been unreported in the last session
            sessions.unreportedDuringLastSession(electron.crashReporter.getLastCrashReport()?.date).then((crashed) => {
                // Check if a previous session was not closed
                return sessions.checkPreviousSession(crashed);
            }, utils.logger.error);
        },
    };
});

exports.electronMinidumpIntegration = electronMinidumpIntegration;
exports.minidumpUrlFromDsn = minidumpUrlFromDsn;//# sourceMappingURL=http://go/sourcemap/sourcemaps/5b19bac7a947f54e4caa3eb7e4c5fbf832389850/node_modules/@sentry/electron/main/integrations/electron-minidump.js.map
