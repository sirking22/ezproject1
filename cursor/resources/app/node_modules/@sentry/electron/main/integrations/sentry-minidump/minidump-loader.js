const utils = require('@sentry/utils');
const electron = require('electron');
const fs = require('fs');
const path = require('path');
const electronNormalize = require('../../electron-normalize.js');
const mutex = require('../../mutex.js');

/** Maximum number of days to keep a minidump before deleting it. */
const MAX_AGE_DAYS = 30;
const MS_PER_DAY = 24 * 3600 * 1000;
/** Minimum number of milliseconds a minidump should not be modified for before we assume writing is complete */
const NOT_MODIFIED_MS = 1000;
const MAX_RETRY_MS = 5000;
const RETRY_DELAY_MS = 500;
const MAX_RETRIES = MAX_RETRY_MS / RETRY_DELAY_MS;
const MINIDUMP_HEADER = 'MDMP';
function delay(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
}
/**
 * Creates a minidump loader
 * @param getMinidumpPaths A function that returns paths to minidumps
 * @param preProcessFile A function that pre-processes the minidump file
 * @returns A function to fetch minidumps
 */
function createMinidumpLoader(getMinidumpPaths, preProcessFile = (file) => file) {
    // The mutex protects against a whole host of reentrancy issues and race conditions.
    const mutex$1 = new mutex.Mutex();
    return async (deleteAll, callback) => {
        // any calls to this function will be queued and run exclusively
        await mutex$1.runExclusive(async () => {
            for (const path of await getMinidumpPaths()) {
                try {
                    if (deleteAll) {
                        continue;
                    }
                    utils.logger.log('Found minidump', path);
                    let stats = await fs.promises.stat(path);
                    const thirtyDaysAgo = new Date().getTime() - MAX_AGE_DAYS * MS_PER_DAY;
                    if (stats.mtimeMs < thirtyDaysAgo) {
                        utils.logger.log(`Ignoring minidump as it is over ${MAX_AGE_DAYS} days old`);
                        continue;
                    }
                    let retries = 0;
                    while (retries <= MAX_RETRIES) {
                        const twoSecondsAgo = new Date().getTime() - NOT_MODIFIED_MS;
                        if (stats.mtimeMs < twoSecondsAgo) {
                            const file = await fs.promises.readFile(path);
                            const data = preProcessFile(file);
                            if (data.length < 10000 || data.subarray(0, 4).toString() !== MINIDUMP_HEADER) {
                                utils.logger.warn('Dropping minidump as it appears invalid.');
                                break;
                            }
                            utils.logger.log('Sending minidump');
                            callback({
                                attachmentType: 'event.minidump',
                                filename: utils.basename(path),
                                data,
                            });
                            break;
                        }
                        utils.logger.log(`Waiting. Minidump has been modified in the last ${NOT_MODIFIED_MS} milliseconds.`);
                        retries += 1;
                        await delay(RETRY_DELAY_MS);
                        // update the stats
                        stats = await fs.promises.stat(path);
                    }
                    if (retries >= MAX_RETRIES) {
                        utils.logger.warn('Timed out waiting for minidump to stop being modified');
                    }
                }
                catch (e) {
                    utils.logger.error('Failed to load minidump', e);
                }
                finally {
                    // We always attempt to delete the minidump
                    try {
                        await fs.promises.unlink(path);
                    }
                    catch (e) {
                        utils.logger.warn('Could not delete minidump', path);
                    }
                }
            }
        });
    };
}
/** Attempts to remove the metadata file so Crashpad doesn't output `failed to stat report` errors to the console */
async function deleteCrashpadMetadataFile(crashesDirectory, waitMs = 100) {
    if (waitMs > 2000) {
        return;
    }
    const metadataPath = path.join(crashesDirectory, 'metadata');
    try {
        await fs.promises.unlink(metadataPath);
        utils.logger.log('Deleted Crashpad metadata file', metadataPath);
    }
    catch (e) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        if (e.code && e.code == 'EBUSY') {
            // Since Crashpad probably still has the metadata file open, we make a few attempts to delete it, backing
            // off and waiting longer each time.
            setTimeout(async () => {
                await deleteCrashpadMetadataFile(crashesDirectory, waitMs * 2);
            }, waitMs);
        }
    }
}
async function readDirsAsync(paths) {
    const found = [];
    for (const path$1 of paths) {
        try {
            const files = await fs.promises.readdir(path$1);
            found.push(...files.map((file) => path.join(path$1, file)));
        }
        catch (_) {
            //
        }
    }
    return found;
}
function crashpadMinidumpLoader() {
    const crashesDirectory = electron.app.getPath('crashDumps');
    const crashpadSubDirectory = process.platform === 'win32' ? 'reports' : 'completed';
    const dumpDirectories = [path.join(crashesDirectory, crashpadSubDirectory)];
    if (process.platform === 'darwin') {
        dumpDirectories.push(path.join(crashesDirectory, 'pending'));
    }
    return createMinidumpLoader(async () => {
        await deleteCrashpadMetadataFile(crashesDirectory).catch((error) => utils.logger.error(error));
        const files = await readDirsAsync(dumpDirectories);
        return files.filter((file) => file.endsWith('.dmp'));
    });
}
/** Crudely parses the minidump from the Breakpad multipart file */
function minidumpFromBreakpadMultipart(file) {
    const binaryStart = file.lastIndexOf('Content-Type: application/octet-stream');
    if (binaryStart > 0) {
        const dumpStart = file.indexOf(MINIDUMP_HEADER, binaryStart);
        const dumpEnd = file.lastIndexOf('----------------------------');
        if (dumpStart > 0 && dumpEnd > 0 && dumpEnd > dumpStart) {
            return file.subarray(dumpStart, dumpEnd);
        }
    }
    return file;
}
function removeBreakpadMetadata(crashesDirectory, paths) {
    // Remove all metadata files and forget about them.
    Promise.all(paths
        .filter((file) => file.endsWith('.txt') && !file.endsWith('log.txt'))
        .map(async (file) => {
        const path$1 = path.join(crashesDirectory, file);
        try {
            await fs.promises.unlink(path$1);
        }
        catch (e) {
            utils.logger.warn('Could not delete', path$1);
        }
    })).catch(() => {
        // ignore since we catch each unlink individually
    });
}
function breakpadMinidumpLoader() {
    const crashesDirectory = electron.app.getPath('crashDumps');
    return createMinidumpLoader(async () => {
        // Breakpad stores all minidump files along with a metadata file directly in
        // the crashes directory.
        const files = await fs.promises.readdir(crashesDirectory);
        removeBreakpadMetadata(crashesDirectory, files);
        return files.filter((file) => file.endsWith('.dmp')).map((file) => path.join(crashesDirectory, file));
    }, minidumpFromBreakpadMultipart);
}
/**
 * Gets the minidump loader
 */
function getMinidumpLoader() {
    return electronNormalize.usesCrashpad() ? crashpadMinidumpLoader() : breakpadMinidumpLoader();
}

exports.createMinidumpLoader = createMinidumpLoader;
exports.getMinidumpLoader = getMinidumpLoader;//# sourceMappingURL=http://go/sourcemap/sourcemaps/5b19bac7a947f54e4caa3eb7e4c5fbf832389850/node_modules/@sentry/electron/main/integrations/sentry-minidump/minidump-loader.js.map
